package com.gitenter.protease.dao.auth;

import java.util.List;

import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;

import com.gitenter.protease.domain.auth.UserBean;
import com.gitenter.protease.domain.auth.OrganizationBean;
import com.gitenter.protease.domain.auth.OrganizationUserMapBean;
import com.gitenter.protease.domain.auth.OrganizationUserRole;

public interface OrganizationUserMapRepository extends CrudRepository<OrganizationUserMapBean, Integer>, OrganizationUserMapSql {
	
	/*
	 * TODO:
	 * 
	 * By checking the SQL generated by this query, (as both user and organization
	 * are EAGER), Hibernate is not smart enough to user the JOIN query to fill all
	 * three objects. Rather, it need to do three queries, first the JOIN one, and then
	 * two other queries to get UserBean and OrganizationBean separately from their
	 * IDs.
	 * 
	 * Wonder if there is any way to optimize it.
	 */
	@Query("select om"
			+ " from OrganizationUserMapBean om"
			+ " join om.organization og"
			+ " join om.user ur"
			+ " where"
			+ " og.id = :organizationId"
			+ " and ur.username = :username")
	public List<OrganizationUserMapBean> findByUsernameAndOrganizationId(
			@Param("username") String username,
			@Param("organizationId") Integer organizationId);
	@Query("select om"
			+ " from OrganizationUserMapBean om"
			+ " join om.organization og"
			+ " join om.user ur"
			+ " where"
			+ " og.id = :organizationId"
			+ " and ur.username = :username"
			+ " and om.role = :role")
	public List<OrganizationUserMapBean> findByUsernameAndOrganizationIdAndRole(
			@Param("username") String username,
			@Param("organizationId") Integer organizationId,
			@Param("role") OrganizationUserRole role);
	/*
	 * TODO:
	 * 
	 * Ideally these queries should call SQL once (the JOIN query) and then
	 * just filled the EAGER dependencies by the input. In reality it query
	 * SQL 3 times, with the later two queries to get UserBean and 
	 * OrganizationBean separately from their IDs.
	 * 
	 * Seeking if there is a way to optimize it.
	 */
	@Query("select om"
			+ " from OrganizationUserMapBean om"
			+ " join om.organization og"
			+ " join om.user ur"
			+ " where"
			+ " og.id = :#{#organization.id}"
			+ " and ur.id = :#{#user.id}")
	public List<OrganizationUserMapBean> fineByUserAndOrganization(
			@Param("user") UserBean user, 
			@Param("organization") OrganizationBean organization);
	@Query("select om"
			+ " from OrganizationUserMapBean om"
			+ " join om.organization og"
			+ " join om.user ur"
			+ " where"
			+ " og.id = :#{#organization.id}"
			+ " and ur.id = :#{#user.id}"
			+ " and om.role = :role")
	public List<OrganizationUserMapBean> fineByUserAndOrganizationAndRole(
			@Param("user") UserBean user, 
			@Param("organization") OrganizationBean organization, 
			@Param("role") OrganizationUserRole role);
	
	/*
	 * There is a Spring Data method "deleteById" doing the same thing.
	 * However, the problem for that is Hibernate is too smart to not
	 * doing any actual SQL query. Since "OrganizationUserMap" is a
	 * modified @ManyToMany relation linking table, with double-link
	 * on both side, it seems extremely hard to cheat Hibernate to let 
	 * him know that this SQL should be executed (I tried to remove the
	 * link on both "UserBean" and "OrganizationBean" side, but it is
	 * just not working).
	 * 
	 * Therefore, the current method I use is to directly generate SQL
	 * query so for sure it will be executed.
	 */
	public int throughSqlDeleteById(Integer mapId);

	public OrganizationUserMapBean saveAndFlush(OrganizationUserMapBean map);
}
