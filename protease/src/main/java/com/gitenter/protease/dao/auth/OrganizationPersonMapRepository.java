package com.gitenter.protease.dao.auth;

import java.util.List;

import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;

import com.gitenter.protease.domain.auth.PersonBean;
import com.gitenter.protease.domain.auth.OrganizationBean;
import com.gitenter.protease.domain.auth.OrganizationPersonMapBean;
import com.gitenter.protease.domain.auth.OrganizationPersonRole;

public interface OrganizationPersonMapRepository extends CrudRepository<OrganizationPersonMapBean, Integer>, OrganizationPersonMapSql {
	
	/*
	 * TODO:
	 * 
	 * By checking the SQL generated by this query, (as both person and organization
	 * are EAGER), Hibernate is not smart enough to user the JOIN query to fill all
	 * three objects. Rather, it need to do three queries, first the JOIN one, and then
	 * two other queries to get PersonBean and OrganizationBean separately from their
	 * IDs.
	 * 
	 * Wonder if there is any way to optimize it.
	 */
	@Query("select om"
			+ " from OrganizationPersonMapBean om"
			+ " join om.organization og"
			+ " join om.person ps"
			+ " where"
			+ " og.id = :organizationId"
			+ " and ps.username = :username")
	public List<OrganizationPersonMapBean> findByUsernameAndOrganizationId(
			@Param("username") String username,
			@Param("organizationId") Integer organizationId);
	@Query("select om"
			+ " from OrganizationPersonMapBean om"
			+ " join om.organization og"
			+ " join om.person ps"
			+ " where"
			+ " og.id = :organizationId"
			+ " and ps.username = :username"
			+ " and om.role = :role")
	public List<OrganizationPersonMapBean> findByUsernameAndOrganizationIdAndRole(
			@Param("username") String username,
			@Param("organizationId") Integer organizationId,
			@Param("role") OrganizationPersonRole role);
	/*
	 * TODO:
	 * 
	 * Ideally these queries should call SQL once (the JOIN query) and then
	 * just filled the EAGER dependencies by the input. In reality it query
	 * SQL 3 times, with the later two queries to get PersonBean and 
	 * OrganizationBean separately from their IDs.
	 * 
	 * Seeking if there is a way to optimize it.
	 */
	@Query("select om"
			+ " from OrganizationPersonMapBean om"
			+ " join om.organization og"
			+ " join om.person ps"
			+ " where"
			+ " og.id = :#{#organization.id}"
			+ " and ps.id = :#{#person.id}")
	public List<OrganizationPersonMapBean> fineByPersonAndOrganization(
			@Param("person") PersonBean person, 
			@Param("organization") OrganizationBean organization);
	@Query("select om"
			+ " from OrganizationPersonMapBean om"
			+ " join om.organization og"
			+ " join om.person ps"
			+ " where"
			+ " og.id = :#{#organization.id}"
			+ " and ps.id = :#{#person.id}"
			+ " and om.role = :role")
	public List<OrganizationPersonMapBean> fineByPersonAndOrganizationAndRole(
			@Param("person") PersonBean person, 
			@Param("organization") OrganizationBean organization, 
			@Param("role") OrganizationPersonRole role);
	
	/*
	 * There is a Spring Data method "deleteById" doing the same thing.
	 * However, the problem for that is Hibernate is too smart to not
	 * doing any actual SQL query. Since "OrganizationPersonMap" is a
	 * modified @ManyToMany relation linking table, with double-link
	 * on both side, it seems extremely hard to cheat Hibernate to let 
	 * him know that this SQL should be executed (I tried to remove the
	 * link on both "PersonBean" and "OrganizationBean" side, but it is
	 * just not working).
	 * 
	 * Therefore, the current method I use is to directly generate SQL
	 * query so for sure it will be executed.
	 */
	public int throughSqlDeleteById(Integer mapId);

	public OrganizationPersonMapBean saveAndFlush(OrganizationPersonMapBean map);
}
