package com.gitenter.protease.dao.auth;

import java.util.List;

import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;

import com.gitenter.protease.domain.auth.MemberBean;
import com.gitenter.protease.domain.auth.OrganizationBean;
import com.gitenter.protease.domain.auth.OrganizationMemberMapBean;
import com.gitenter.protease.domain.auth.OrganizationMemberRole;

public interface OrganizationMemberMapRepository extends CrudRepository<OrganizationMemberMapBean, Integer>, OrganizationMemberMapSql {
	
	/*
	 * TODO:
	 * 
	 * By checking the SQL generated by this query, (as both member and organization
	 * are EAGER), Hibernate is not smart enough to user the JOIN query to fill all
	 * three objects. Rather, it need to do three queries, first the JOIN one, and then
	 * two other queries to get MemberBean and OrganizationBean separately from their
	 * IDs.
	 * 
	 * Wonder if there is any way to optimize it.
	 */
	@Query("select om"
			+ " from OrganizationMemberMapBean om"
			+ " join om.organization og"
			+ " join om.member mb"
			+ " where"
			+ " og.id = :organizationId"
			+ " and mb.username = :username")
	public List<OrganizationMemberMapBean> findByUsernameAndOrganizationId(
			@Param("username") String username,
			@Param("organizationId") Integer organizationId);
	@Query("select om"
			+ " from OrganizationMemberMapBean om"
			+ " join om.organization og"
			+ " join om.member mb"
			+ " where"
			+ " og.id = :organizationId"
			+ " and mb.username = :username"
			+ " and om.role = :role")
	public List<OrganizationMemberMapBean> findByUsernameAndOrganizationIdAndRole(
			@Param("username") String username,
			@Param("organizationId") Integer organizationId,
			@Param("role") OrganizationMemberRole role);
	/*
	 * TODO:
	 * 
	 * Ideally these queries should call SQL once (the JOIN query) and then
	 * just filled the EAGER dependencies by the input. In reality it query
	 * SQL 3 times, with the later two queries to get MemberBean and 
	 * OrganizationBean separately from their IDs.
	 * 
	 * Seeking if there is a way to optimize it.
	 */
	@Query("select om"
			+ " from OrganizationMemberMapBean om"
			+ " join om.organization og"
			+ " join om.member mb"
			+ " where"
			+ " og.id = :#{#organization.id}"
			+ " and mb.id = :#{#member.id}")
	public List<OrganizationMemberMapBean> fineByMemberAndOrganization(
			@Param("member") MemberBean member, 
			@Param("organization") OrganizationBean organization);
	@Query("select om"
			+ " from OrganizationMemberMapBean om"
			+ " join om.organization og"
			+ " join om.member mb"
			+ " where"
			+ " og.id = :#{#organization.id}"
			+ " and mb.id = :#{#member.id}"
			+ " and om.role = :role")
	public List<OrganizationMemberMapBean> fineByMemberAndOrganizationAndRole(
			@Param("member") MemberBean member, 
			@Param("organization") OrganizationBean organization, 
			@Param("role") OrganizationMemberRole role);
	
	/*
	 * There is a Spring Data method "deleteById" doing the same thing.
	 * However, the problem for that is Hibernate is too smart to not
	 * doing any actual SQL query. Since "OrganizationMemberMap" is a
	 * modified @ManyToMany relation linking table, with double-link
	 * on both side, it seems extremely hard to cheat Hibernate to let 
	 * him know that this SQL should be executed (I tried to remove the
	 * link on both "MemberBean" and "OrganizationBean" side, but it is
	 * just not working).
	 * 
	 * Therefore, the current method I use is to directly generate SQL
	 * query so for sure it will be executed.
	 */
	public int throughSqlDeleteById(Integer mapId);

	public OrganizationMemberMapBean saveAndFlush(OrganizationMemberMapBean map);
}
